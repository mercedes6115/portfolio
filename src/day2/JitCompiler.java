package day2;

public class JitCompiler {

    // Latency 원인

    // 1. 클래스 로더(Class Loader)

    // 자바 클래스가 로드되는 과정
    // JVM 에서 자바의 클래스를 읽어오기 위해 자바 클래스 로더를 사용한다
    // 클래스 로더는 클래스 파일을 찾고, 메모리에 로드해 살행 가능한 상태로 만드는 역할을 한다
    // 과정
    // 1. Class Loading: 클래스 파일을 가져와 JVM 메모리에 적재한다
    // 이 단계도 크게 JVM 기본 클래스와 Java 코드를 로딩하는 Bootstrap Class Loading
    // 자바 핵심 라이브러리를 로딩하는 Extension Class Loading
    // 개발자가 직접 개발하여 Classpath 에 있는 클래스를 로딩하는 Application Class Loading 단계로 나뉟나
    // 2. Class Linking: 클래스가 참조하는 다른 클래스, 매서드, 필드 등을 확인하고 필요하면
    // 메모리 상에서 연결하는 단계
    // 3. Class Initialization: 클래스 변수를 초기화 하거나, static 블록 내의 코드를 실행하는 등의 클래스 초기화 작업을 수행한다
    // 클래스 로더는 일반적으로 Lazy Loading 방식 즉, 어플리케이션이 시작 할 때 로딩되는 것이 아니라,
    // 클래스가 필요한 시점까지 로딩을 지연하는 방식이다
    // 정리하면 클래스 로더는 클래스가 최초로 필요해진 시점에 클래스를 로딩 한다는 것이다.
    // 이게 Latency 의 첫번째 이유이다
    // 배포 직후에는 대부분의 클래스들이 한번도 사용되지 않으므로 클래스 로더에 의해 메모리에 적재되지 않는 상태인데
    // 그런 상태에서 요청이 들어오게 되면 그제서야 클래스로더가 클래스를 메모리에 적재하면서 이 과정속에서 Latency 가 발생하는 것이다

    // 2. JIT 컴파일
    //
    // 자바 컴파일 과정
    // 자바나 코틀린 소스코드는 중간언어로 컴파일된다
    // 이 컴파일된 결과는 바이트코드 라고 불리며 .class 확장자를 갖는다
    // 이 바이트 코드는 어플리케이션에서 사용되는 다른 여러 리소스들과 함께 묶어, 실행될 수 있는 JAR 나 WAR 파일로 아카이브 된다
    // 이런 빌드과정을 거쳐 JAR, WAR 을 실행하면 JVM 은 바이트 코드를 한줄 한줄 읽어 기계어로 번역한 뒤 실행하는데
    // 이 과정을 인터프리트라고 한다
    //
    // 그럼 왜 자바는 소스코드를 바로 기계어로 번역하지 않고 바이트 코드라는 중간 언어를 만들까
    // 자바의 핵심 철학 중 하나님 Write Once, Run Anywhere 때문 자바는 플랫폼 독립전인 언어를 지향한다
    // 자바는 바이트코드를 사용함으로써 이런 문제를 해결함
    // JVM 은 바이트 코드를 기계어로 번역할 때 플랫좀 종속적인 작업을 처리한다
    // 이것이 자바가 높은 이식성을 가질 수 있는 이유다

    // 그러나 이런 중간 언어를 사용해도 있는 단점
    // 실행 속도가 느리다는 점
    // 이건 모든 인러프리팅 방식을 사용하는 언어가 가지고 있는 고질적인 문제다
    // 컴파일 언어는 소스코드를 컴파일 하면서 최적화를 수행한다
    // 이미 최적화되어 준비된 기계어를 읽는 컴파일 언어에 비하면 인터프리터 언어는 성능이 부족할 수 밖에없다

    // JIT 컴파일러의 도입
    // 이런 인터프리팅 방식의 성능 문제 해결을 위해 도입한게 JIT 컴파일
    // JIT 컴파일러는 어플리케이션 실행 중 동적으로 바이트 코드를 기계어로 컴파일 한다
    // 이때 실행중 동적으로 바이트 코드를 기계어로 컴파일 한다하지만 모든 코드를 기계어로 컴파일 하는건 기동 시간에 있어서 문제가 될텐데 그럼 JIT컴파일러는 코드의 어떤 부분을 기계어로 번역하는것일지?

    // JIT 컴파일러는 어플이케이션에서 자주 실행된다고 판단되는 특정 부분만을 기계어로 번역한다
    // 이 부분을 핫스팟이라고 한다
    // JIT 컴파일러는 실행중인 어플리케이션의 동작을 분석하고 코드의 실행 횟수, 루프 반복 횟수, 매서드 호출 등의 정보를 측정하고 기록한다 => 프로파일림
    // 프로파일링의 결과를 토대로 핫스팟을 식별하고 JIT컴파일러는 메서드 단위로 바이트 코드를 기계어로 번역한다
    // JIT 컴파일러는 이렇게 번역된 기계어를 코드 캐시라는 캐시 공간에 저장한다
    // 이 코드캐시에 기계어를 저장하면, 핫스팟으로 판단되는 코드는 다시 컴파일하지 않고 코드캐시에서 꺼내서 사용할 수 있으므로 성능 향상을 이룰 수 있다
    // 이 과정을 JIT warm up으로 이해하면 된다


    // JIT 컴파일러가 최적화된 성능을 발휘하기 위해 필요한 준비 단계
    // 초기에는 인터프리터로 실행되며, 실행 패턴을 분석한 후 핫스팟 코드에 최적화를 적용
    // 이 과정은 프로그램의 초기 실행 속도를 높이고, 최적화 비용을 최소화하며, 결과적으로 실행 성능을 크게 향상


    // JIT 내부동작
    // 컴파일 과정이 최적화 수준에 따라 복수의 단계로 나뉘져있다 => Tiered Compilation

    // C1 컴파일러와 C2 컴파일러
    // C1 컴파일러는 가능한 빠른 실행 속도를 위해 코드를 가능한 빠르게 최적화하고 컴파일 한다
    // 그중 특정 메서드가 C1 컴파일러의 임계치 설정 이상으로 호출되면, 해당 메서드의 코드는 C1컴파일러를 통해 제한된 수준으로 최적화 한다
    // 그리고 컴파일된 기계어는 코드 캐시에 저장된다
    // 이후 매서드가 C2 컴파일러의 임계치 설정보다 많이 호출되면 코드는 C2 컴파일러에 의해 최적화되고 컴파일 된다
    // C2 컴파일러는 C1 컴파일러보다 더 높은 수준의 최적화를 수행한다
    // 최적화가 끝나면 마찬가지로 코드캐시에 기계어를 저장한다

    // JIT Tiered Compilation
    // Level 0 - Interpreted Code: JVM은 초기에 모든 코드를 인터프리터를 통해 실행한다. 이 단계는 앞서 살펴본것과 같이, 컴파일된 기계어를 실행하는 것보다 성능이 낮다.
    // Level 1 - Simple C1 Compiled Code: Level 1 은 JIT 컴파일러가 단순하다고 판단한 메서드에 대해 사용된다. 여기서 컴파일된 메서드들은 복잡도가 낮아, C2 컴파일러로 컴파일한다고 하더라도 성능이 향상되지 않는다. 따라서 추가적인 최적화가 필요 없으므로 프로파일링 정보도 수집하지 않는다.
    // Level 2 - Limited C1 Compiled Code: 제한된 수준으로 프로파일링과 최적화를 진행하는 단계이다. C2 컴파일러 큐가 꽉 찬경우 실행된다.
    // Level 3 - Full C1 Compiled Code: 최대 수준으로 프로파일링과 최적화를 진행한다. 즉 일반적인 상황에서 수행된다.
    // Level 4 - C2 Compiled Code: 애플리케이션의 장기적인 성능을 위해 C2 컴파일러가 최적화를 수행한다. Level 4에서 최적화된 코드는 완전히 최적화 되었다고 간주되어, 더이상 프로파일링 정보를 수집하지 않는다.


    // 간단 정리
    // JVM Warm up
    // JVM은 자주 실행되는 코드를 컴파일하고 캐시한다
    // 클래스는 필요할때 Lazy Loading으로 메모리에 적재된다
    // Latency의 원인
    // 1. 클래스가 메모리에 적재되지 않고(Lazy Loading에의함)
    // 2. 코드가 최적화된 기계어로 컴파일되지 않았기 때문

    // 스프링에는 ApplicationRunner라는 인터페이스가 있다
    // warm up해줄 메서드를 한번 호출해준다

}